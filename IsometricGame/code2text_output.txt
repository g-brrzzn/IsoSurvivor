Code:

.config\dotnet-tools.json:
Directory: .config

{
  "version": 1,
  "isRoot": true,
  "tools": {
    "dotnet-mgcb": {
      "version": "3.8.4",
      "commands": [
        "mgcb"
      ]
    },
    "dotnet-mgcb-editor": {
      "version": "3.8.4",
      "commands": [
        "mgcb-editor"
      ]
    },
    "dotnet-mgcb-editor-linux": {
      "version": "3.8.4",
      "commands": [
        "mgcb-editor-linux"
      ]
    },
    "dotnet-mgcb-editor-windows": {
      "version": "3.8.4",
      "commands": [
        "mgcb-editor-windows"
      ]
    },
    "dotnet-mgcb-editor-mac": {
      "version": "3.8.4",
      "commands": [
        "mgcb-editor-mac"
      ]
    }
  }
}

.vscode\launch.json:
Directory: .vscode

{
    // Use IntelliSense to learn about possible attributes.
    // Hover to view descriptions of existing attributes.
    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387
    "version": "0.2.0",
    "configurations": [
      {
        "name": "C#: IsometricGame Debug",
        "type": "dotnet",
        "request": "launch",
        "projectPath": "${workspaceFolder}/IsometricGame.csproj"
      }
    ],
  }

AssetManager.cs:
Directory: .

﻿using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Audio;
using Microsoft.Xna.Framework.Media;
using Microsoft.Xna.Framework.Content;
using System.Collections.Generic;
using System;
using Microsoft.Xna.Framework;
namespace IsometricGame
{
    public class AssetManager
    {
        public Dictionary<string, Texture2D> Images { get; private set; } = new Dictionary<string, Texture2D>();
        public Dictionary<string, SoundEffect> Sounds { get; private set; } = new Dictionary<string, SoundEffect>();
        public Dictionary<string, SpriteFont> Fonts { get; private set; } = new Dictionary<string, SpriteFont>();
        public Song Music { get; private set; }
        private Texture2D CreateRectangleTexture(GraphicsDevice device, int width, int height, Color color)
        {
            var texture = new Texture2D(device, width, height);
            Color[] data = new Color[width * height];
            for (int i = 0; i < data.Length; i++)
            {
                data[i] = color;
            }
            texture.SetData(data);
            return texture;
        }
        private Texture2D CreateDiamondTexture(GraphicsDevice device, int width, int height, Color color)
        {
            var texture = new Texture2D(device, width, height);
            Color[] data = new Color[width * height];
            float midX = (width - 1) / 2.0f;
            float midY = (height - 1) / 2.0f;

            for (int y = 0; y < height; y++)
            {
                for (int x = 0; x < width; x++)
                {
                    float dx = Math.Abs(x - midX);
                    float dy = Math.Abs(y - midY);
                    if ((dx / (width / 2.0f)) + (dy / (height / 2.0f)) <= 1.0f)
                    {
                        data[y * width + x] = color;
                    }
                    else
                    {
                        data[y * width + x] = Color.Transparent;
                    }
                }
            }
            texture.SetData(data);
            return texture;
        }

        public void LoadContent(ContentManager content, GraphicsDevice graphicsDevice)
        {
            var playerSprite = CreateDiamondTexture(graphicsDevice, 16, 32, Constants.PlayerColorGreen);
            Images["player_idle_south"] = playerSprite;
            Images["player_idle_west"] = playerSprite;
            Images["player_idle_north"] = playerSprite; // ADICIONADO
            Images["player_idle_east"] = playerSprite;  // ADICIONADO

            Images["icon"] = playerSprite;            
            Images["bullet_player"] = CreateRectangleTexture(graphicsDevice, 8, 8, Color.Yellow);
            Images["bullet_enemy"] = CreateRectangleTexture(graphicsDevice, 8, 8, Color.Magenta);
            var enemySprite = CreateDiamondTexture(graphicsDevice, 16, 32, Color.DarkRed);
            Images["enemy1_idle_south"] = enemySprite;
            Images["enemy1_idle_west"] = enemySprite;
            Images["enemy1_idle_north"] = enemySprite; // ADICIONADO
            Images["enemy1_idle_east"] = enemySprite;  // ADICIONADO

            // Cria uma textura de "chão" baseada no IsoTileSize
            var floorTile = CreateDiamondTexture(
                graphicsDevice,
                Constants.IsoTileSize.X, // 64
                Constants.IsoTileSize.Y, // 32
                Color.DarkGreen);
            Images["tile_floor"] = content.Load<Texture2D>("sprites/tiles/grass_tile1");

            // 2. Removemos o código que gerava o chão placeholder
            /* var floorTile = CreateDiamondTexture(
                graphicsDevice, 
                Constants.IsoTileSize.X, // 64
                Constants.IsoTileSize.Y, // 32
                Color.DarkGreen);
            Images["tile_floor"] = floorTile;
            */

            // 3. ATUALIZAÇÃO AUTOMÁTICA DA PAREDE:
            // O código da parede (wallTile) usa Constants.IsoTileSize.X.
            // Como mudamos o X para 32, a parede agora será criada
            // como um losango 32x32, combinando com seu novo tile.
            // Nenhuma mudança é necessária aqui.
            Images["tile_wall"] = content.Load<Texture2D>("sprites/tiles/grass_tile3");

            Sounds["shoot"] = content.Load<SoundEffect>("sound/shoot");
            Sounds["hit"] = content.Load<SoundEffect>("sound/hit");
            Sounds["menu_select"] = content.Load<SoundEffect>("sound/impactMetal_002");
            Sounds["menu_confirm"] = content.Load<SoundEffect>("sound/forceField_001");
            Music = content.Load<Song>("sound/victory");
            Fonts["captain_32"] = content.Load<SpriteFont>("Captain32");
            Fonts["captain_42"] = content.Load<SpriteFont>("Captain42");
            Fonts["captain_80"] = content.Load<SpriteFont>("Captain80");
        }
    }
}

bin\Debug\net8.0\IsometricGame.deps.json:
Directory: bin\Debug\net8.0

{
  "runtimeTarget": {
    "name": ".NETCoreApp,Version=v8.0",
    "signature": ""
  },
  "compilationOptions": {},
  "targets": {
    ".NETCoreApp,Version=v8.0": {
      "IsometricGame/1.0.0": {
        "dependencies": {
          "MonoGame.Content.Builder.Task": "3.8.4",
          "MonoGame.Framework.DesktopGL": "3.8.4"
        },
        "runtime": {
          "IsometricGame.dll": {}
        }
      },
      "MonoGame.Content.Builder.Task/3.8.4": {},
      "MonoGame.Framework.DesktopGL/3.8.4": {
        "dependencies": {
          "MonoGame.Library.OpenAL": "1.23.1.10",
          "MonoGame.Library.SDL": "2.32.2.1",
          "NVorbis": "0.10.4"
        },
        "runtime": {
          "lib/net8.0/MonoGame.Framework.dll": {
            "assemblyVersion": "3.8.4.0",
            "fileVersion": "3.8.4.0"
          }
        }
      },
      "MonoGame.Library.OpenAL/1.23.1.10": {
        "runtimeTargets": {
          "runtimes/android-arm/native/libopenal.so": {
            "rid": "android-arm",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/android-arm64/native/libopenal.so": {
            "rid": "android-arm64",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/android-x64/native/libopenal.so": {
            "rid": "android-x64",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/android-x86/native/libopenal.so": {
            "rid": "android-x86",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/ios-arm64/native/libopenal.dylib": {
            "rid": "ios-arm64",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/iossimulator-arm64/native/libopenal.dylib": {
            "rid": "iossimulator-arm64",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/iossimulator-x64/native/libopenal.dylib": {
            "rid": "iossimulator-x64",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/linux-x64/native/libopenal.so": {
            "rid": "linux-x64",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/osx/native/libopenal.dylib": {
            "rid": "osx",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/win-x64/native/openal.dll": {
            "rid": "win-x64",
            "assetType": "native",
            "fileVersion": "1.23.1.0"
          }
        }
      },
      "MonoGame.Library.SDL/2.32.2.1": {
        "runtimeTargets": {
          "runtimes/linux-x64/native/libSDL2-2.0.so.0": {
            "rid": "linux-x64",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/osx/native/libSDL2-2.0.0.dylib": {
            "rid": "osx",
            "assetType": "native",
            "fileVersion": "0.0.0.0"
          },
          "runtimes/win-x64/native/SDL2.dll": {
            "rid": "win-x64",
            "assetType": "native",
            "fileVersion": "2.32.2.0"
          }
        }
      },
      "NVorbis/0.10.4": {
        "dependencies": {
          "System.Memory": "4.5.3",
          "System.ValueTuple": "4.5.0"
        },
        "runtime": {
          "lib/netstandard2.0/NVorbis.dll": {
            "assemblyVersion": "0.10.4.0",
            "fileVersion": "0.10.4.0"
          }
        }
      },
      "System.Memory/4.5.3": {},
      "System.ValueTuple/4.5.0": {}
    }
  },
  "libraries": {
    "IsometricGame/1.0.0": {
      "type": "project",
      "serviceable": false,
      "sha512": ""
    },
    "MonoGame.Content.Builder.Task/3.8.4": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-Oc/tp6liQ34BkBCrdQO23JDf1Z8r11kKeL9oXSlEfUiRSQYs7C0TYaKIjhfYGjSRaV7JaFIisLDToWpnf7ztKg==",
      "path": "monogame.content.builder.task/3.8.4",
      "hashPath": "monogame.content.builder.task.3.8.4.nupkg.sha512"
    },
    "MonoGame.Framework.DesktopGL/3.8.4": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-2WR/vPNPcmQ9h4EhMkfpUfMW0Krm6pX0ElkZwSRI1IUecPuzLeXt0i9NRwGxZBUdcNdNxACCmswrxSf4B95Obg==",
      "path": "monogame.framework.desktopgl/3.8.4",
      "hashPath": "monogame.framework.desktopgl.3.8.4.nupkg.sha512"
    },
    "MonoGame.Library.OpenAL/1.23.1.10": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-4/F4FFyt7OYhtEmgi/Qmv01eC6GfQ9dkIPsymgkwJ/tV7PewmWrHg/LvTKjd6R+5j/tlO8JkjsEb0Aje6bxfxw==",
      "path": "monogame.library.openal/1.23.1.10",
      "hashPath": "monogame.library.openal.1.23.1.10.nupkg.sha512"
    },
    "MonoGame.Library.SDL/2.32.2.1": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-T4E2ppGlSTC2L9US1rxtdg3qTbarRzNId31xZoumUW9cf9Nq8nRQPMu9GzvZGrhfSySf0+UWPEj1rlicps+P/w==",
      "path": "monogame.library.sdl/2.32.2.1",
      "hashPath": "monogame.library.sdl.2.32.2.1.nupkg.sha512"
    },
    "NVorbis/0.10.4": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-WYnil3DhQHzjCY0dM9I2B3r1vWip90AOuQd25KE4NrjPQBg0tBJFluRLm5YPnO5ZLDmwrfosY8jCQGQRmWI/Pg==",
      "path": "nvorbis/0.10.4",
      "hashPath": "nvorbis.0.10.4.nupkg.sha512"
    },
    "System.Memory/4.5.3": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-3oDzvc/zzetpTKWMShs1AADwZjQ/36HnsufHRPcOjyRAAMLDlu2iD33MBI2opxnezcVUtXyqDXXjoFMOU9c7SA==",
      "path": "system.memory/4.5.3",
      "hashPath": "system.memory.4.5.3.nupkg.sha512"
    },
    "System.ValueTuple/4.5.0": {
      "type": "package",
      "serviceable": true,
      "sha512": "sha512-okurQJO6NRE/apDIP23ajJ0hpiNmJ+f0BwOlB/cSqTLQlw5upkf+5+96+iG2Jw40G1fCVCyPz/FhIABUjMR+RQ==",
      "path": "system.valuetuple/4.5.0",
      "hashPath": "system.valuetuple.4.5.0.nupkg.sha512"
    }
  }
}

bin\Debug\net8.0\IsometricGame.runtimeconfig.json:
Directory: bin\Debug\net8.0

{
  "runtimeOptions": {
    "tfm": "net8.0",
    "rollForward": "Major",
    "framework": {
      "name": "Microsoft.NETCore.App",
      "version": "8.0.0"
    },
    "configProperties": {
      "System.Runtime.Serialization.EnableUnsafeBinaryFormatterSerialization": false,
      "System.Runtime.TieredCompilation": false
    }
  }
}

Camera.cs:
Directory: .

﻿using Microsoft.Xna.Framework;
using System;

namespace IsometricGame
{
    public class Camera
    {
        public Vector2 Position { get; private set; }
        public float Zoom { get; private set; }
        public Matrix Transform { get; private set; }

        private int _viewportWidth;
        private int _viewportHeight;

        public Camera(int viewportWidth, int viewportHeight)
        {
            _viewportWidth = viewportWidth;
            _viewportHeight = viewportHeight;
            Zoom = 1.0f;
            Position = Vector2.Zero;

            // --- ADIÇÃO 1 ---
            // Garante que a matriz seja calculada na inicialização
            UpdateMatrix();
        }

        // --- ADIÇÃO 2 ---
        // Novo método para definir o zoom e atualizar a matriz
        public void SetZoom(float zoom)
        {
            // Math.Max para evitar zoom negativo ou zero
            Zoom = Math.Max(zoom, 0.1f);
            UpdateMatrix();
        }

        private void UpdateMatrix()
        {
            // --- MODIFICAÇÃO 3 ---
            // Adicionamos Matrix.CreateScale(Zoom) à transformação
            Transform = Matrix.CreateTranslation(-Position.X, -Position.Y, 0) *
                        Matrix.CreateScale(Zoom, Zoom, 1f) * // <-- LINHA ADICIONADA
                        Matrix.CreateTranslation(_viewportWidth / 2, _viewportHeight / 2, 0);
        }

        public void Follow(Vector2 targetPosition)
        {
            Position = Vector2.Lerp(Position, targetPosition, 0.1f);
            UpdateMatrix();
        }
        public Matrix GetViewMatrix()
        {
            return Transform;
        }
        public Vector2 ScreenToWorld(Vector2 screenPosition)
        {
            return Vector2.Transform(screenPosition, Matrix.Invert(Transform));
        }
    }
}

Classes\Bullet.cs:
Directory: Classes

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;

namespace IsometricGame.Classes
{
    public class BulletOptions
    {
        public float? Angle { get; set; }
        public int? Count { get; set; }
        public float? SpreadArc { get; set; }
        public float? SpeedScale { get; set; } = 10.0f;    }

    public class Bullet : Sprite
    {
        public static Texture2D PlayerImage { get; set; }
        public static Texture2D EnemyImage { get; set; }

        public bool IsFromPlayer { get; private set; }

        public Bullet(Vector2 worldPos, Vector2 worldDirection, bool isFromPlayer, BulletOptions options = null)
            : base(null, worldPos)
        {
            IsFromPlayer = isFromPlayer;
            options ??= new BulletOptions();            float speedScale = options.SpeedScale.Value;

            Texture = isFromPlayer ? PlayerImage : EnemyImage;

            if (Texture == null)
                Texture = Particles.Explosion.PixelTexture;


            if (worldDirection.LengthSquared() > 0)
            {
                WorldVelocity = Vector2.Normalize(worldDirection) * speedScale;
            }
            else
            {
                WorldVelocity = new Vector2(0, 1) * speedScale;            }
        }

        public static void LoadAssets(AssetManager assets)
        {
            PlayerImage = assets.Images["bullet_player"];
            EnemyImage = assets.Images["bullet_enemy"];
        }

        public static List<Bullet> CreateBullets(string pattern, Vector2 worldPos, Vector2 worldDirection, bool isFromPlayer, BulletOptions options = null)
        {
            var bullets = new List<Bullet>();
            options ??= new BulletOptions();

            if (pattern == "single")
            {
                bullets.Add(new Bullet(worldPos, worldDirection, isFromPlayer, options));
            }

            return bullets;
        }
        public override void Update(GameTime gameTime, float dt)
        {
            base.Update(gameTime, dt);

            float limit = Math.Max(Constants.WorldSize.X, Constants.WorldSize.Y) * 1.5f;            if (Math.Abs(WorldPosition.X) > limit || Math.Abs(WorldPosition.Y) > limit)
            {
                Kill();
            }
        }
        public override void Draw(SpriteBatch spriteBatch)
        {
            if (Texture != null && !IsRemoved)
            {
                // Calcula a posição "flutuante"
                Vector2 floatingScreenPos = ScreenPosition - new Vector2(0, 12);

                // --- INÍCIO DA ADIÇÃO ---
                Vector2 drawPosition = new Vector2(
                    MathF.Round(floatingScreenPos.X),
                    MathF.Round(floatingScreenPos.Y)
                );
                // --- FIM DA ADIÇÃO ---

                float depth = IsoMath.GetDepth(WorldPosition);

                spriteBatch.Draw(Texture,
                                 drawPosition, // Usa a posição arredondada
                                 null,
                                 Color.White,
                                 0f,
                                 Origin,
                                 1.0f,
                                 SpriteEffects.None,
                                 depth);
            }
        }
    }
}

Classes\Enemy1.cs:
Directory: Classes

﻿using Microsoft.Xna.Framework;
using System.Collections.Generic;

namespace IsometricGame.Classes
{
    public class Enemy1 : EnemyBase
    {
        public Enemy1(Vector2 worldPos)
            : base(worldPos, new List<string> { "enemy1_idle_south", "enemy1_idle_west" })
        {
            Life = 1;
            Weight = 1;
            Speed = 3.0f;        }
    }
}

Classes\EnemyBase.cs:
Directory: Classes

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Audio;
using IsometricGame.Classes.Particles;
using System.Collections.Generic;
using System;

namespace IsometricGame.Classes
{
    public class EnemyBase : Sprite
    {
        public static SoundEffect HitSound { get; set; }

        protected Dictionary<string, Texture2D> _sprites;
        protected string _currentDirection = "south";
        protected Explosion _explosion;

        public int Life { get; protected set; }
        public float Speed { get; protected set; } = 3.0f;        public int Weight { get; protected set; }

        private double _lastHit;
        private double _hitFlashDuration = 100;
        private bool _isHit = false;


        public EnemyBase(Vector2 worldPos, List<string> spriteKeys) : base(null, worldPos)
        {
            _sprites = LoadSprites(spriteKeys);
            _explosion = new Explosion();

            if (_sprites.Count > 0 && _sprites.ContainsKey(_currentDirection))
            {
                UpdateTexture(_sprites[_currentDirection]);
                if (Texture != null)
                    Origin = new Vector2(Texture.Width / 2f, Texture.Height);
            }

            if (Texture != null)
                _explosion.Create(this.ScreenPosition.X, this.ScreenPosition.Y - Texture.Height / 2f, speed: -5);
            Life = 3;
            Weight = 1;
        }

        public static void LoadAssets(AssetManager assets)
        {
            HitSound = assets.Sounds["hit"];
        }

        private Dictionary<string, Texture2D> LoadSprites(List<string> spriteKeys)
        {
            var dict = new Dictionary<string, Texture2D>();
            foreach (var key in spriteKeys)
            {
                if (GameEngine.Assets.Images.TryGetValue(key, out Texture2D texture))
                {
                    string direction = key.Contains("south") ? "south" : key.Contains("west") ? "west" : "south";
                    dict[direction] = texture;
                }
            }
            return dict;
        }

        public void Damage(GameTime gameTime)
        {
            _lastHit = gameTime.TotalGameTime.TotalMilliseconds;
            _isHit = true;            if (Texture != null)
                _explosion.Create(this.ScreenPosition.X, this.ScreenPosition.Y - Texture.Height / 2f);

            Life -= 1;
            if (Life <= 0)
            {
                GameEngine.ScreenShake = Math.Max(GameEngine.ScreenShake, 5);
                Kill();
            }
        }

        protected virtual void Shoot()
        {
            if (GameEngine.Player == null || GameEngine.Player.IsRemoved) return;

            for (int i = 0; i < Weight; i++)
            {
                if (GameEngine.Random.Next(0, 500 / Weight) < 1)                {
                    Vector2 direction = GameEngine.Player.WorldPosition - this.WorldPosition;
                    if (direction != Vector2.Zero)
                        direction.Normalize();

                    var bullets = Bullet.CreateBullets(
                        pattern: "single",
                        worldPos: this.WorldPosition,
                        worldDirection: direction,
                        isFromPlayer: false
                    );

                    foreach (var bullet in bullets)
                    {
                        GameEngine.EnemyBullets.Add(bullet);
                        GameEngine.AllSprites.Add(bullet);
                    }
                }
            }
        }
        public virtual void Move(GameTime gameTime, float dt)
        {
            if (GameEngine.Player == null || GameEngine.Player.IsRemoved)
            {
                WorldVelocity = Vector2.Zero;
                return;
            }
            ;

            Vector2 direction = GameEngine.Player.WorldPosition - this.WorldPosition;
            float distance = direction.Length();

            if (distance > 0.5f)
            {
                direction.Normalize();
                WorldVelocity = direction * Speed;
            }
            else
            {
                WorldVelocity = Vector2.Zero;
            }
            if (Math.Abs(direction.X) > Math.Abs(direction.Y))
            {
                _currentDirection = direction.X > 0 ? "south" : "west";            }
            else if (direction.LengthSquared() > 0)
            {
                _currentDirection = direction.Y > 0 ? "south" : "west";            }

            if (_sprites.ContainsKey(_currentDirection))
            {
                UpdateTexture(_sprites[_currentDirection]);
                if (Texture != null)
                    Origin = new Vector2(Texture.Width / 2f, Texture.Height);
            }
                
        }
        public override void Update(GameTime gameTime, float dt)
        {
            Move(gameTime, dt);
            Shoot();
            _explosion.Update(dt);
            if (_isHit && gameTime.TotalGameTime.TotalMilliseconds - _lastHit > _hitFlashDuration)
            {
                _isHit = false;
            }
            base.Update(gameTime, dt);
        }

        public override void Draw(SpriteBatch spriteBatch)
        {
            Color tint = _isHit ? Color.Red : Color.White;
            if (Texture != null && !IsRemoved)
            {
                // --- INÍCIO DA ADIÇÃO ---
                Vector2 drawPosition = new Vector2(
                    MathF.Round(ScreenPosition.X),
                    MathF.Round(ScreenPosition.Y)
                );
                // --- FIM DA ADIÇÃO ---

                float depth = IsoMath.GetDepth(WorldPosition);

                spriteBatch.Draw(Texture,
                                 drawPosition, // Usa a posição arredondada
                                 null,
                                 tint,
                                 0f,
                                 Origin,
                                 1.0f,
                                 SpriteEffects.None,
                                 depth);
            }

            _explosion.Draw(spriteBatch);
        }
    }
}

Classes\Particles\Explosion.cs:
Directory: Classes\Particles

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;
using System.Collections.Generic;

namespace IsometricGame.Classes.Particles
{
    public class Explosion
    {
        public static Texture2D PixelTexture { get; set; }

        private List<Particle> _particles = new List<Particle>();

        public void Create(float x, float y,
                           Color? color = null,
                           int count = 80,
                           float eRange = 50,
                           float speed = 400.0f, float rangeVariation = 0.4f)
        {
            Vector2 origin = new Vector2(x, y);
            Color partColor = color ?? Constants.TitleYellow1;

            for (int i = 0; i < count; i++)
            {
                float angle = (float)(GameEngine.Random.NextDouble() * 2 * Math.PI);
                float magnitude = (float)(GameEngine.Random.NextDouble() * 0.8 + 0.2) * speed; Vector2 vel = new Vector2((float)Math.Cos(angle), (float)Math.Sin(angle)) * magnitude;
                float randomFactor = 1.0f + (float)(GameEngine.Random.NextDouble() * 2 - 1) * rangeVariation;
                float particleRange = eRange * randomFactor;

                Particle p = new Particle(origin, origin, vel, partColor, particleRange);
                _particles.Add(p);
            }
        }
        public void Update(float dt)
        {
            for (int i = _particles.Count - 1; i >= 0; i--)
            {
                var p = _particles[i];
                p.Position += p.Velocity * dt; _particles[i] = p;

                if (Vector2.DistanceSquared(p.Position, p.Origin) > (p.MaxRange * p.MaxRange))
                {
                    _particles.RemoveAt(i);
                }
            }
        }

        public void Draw(SpriteBatch spriteBatch)
        {
            if (PixelTexture == null) return;

            foreach (var p in _particles)
            {
                // --- INÍCIO DA MODIFICAÇÃO ---
                // Muda a profundidade (último parâmetro) de 1.0f para 0.0f
                spriteBatch.Draw(PixelTexture, p.Position, null, p.Color, 0f,
                                 new Vector2(0.5f, 0.5f), 6f, SpriteEffects.None, 0.0f);
                // --- FIM DA MODIFICAÇÃO ---
            }
        }
    }
}

Classes\Particles\Fall.cs:
Directory: Classes\Particles

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;using System.Collections.Generic;

namespace IsometricGame.Classes.Particles
{
    public struct Drop
    {
        public Vector2 Position;
        public Vector2 Velocity;        public int Radius;
        public Color Color;
    }

    public class Fall
    {
        private List<Drop> _drops = new List<Drop>();
        private const float _maxFallSpeed = 150f;
        public Fall(int amount)
        {
            int width = Constants.InternalResolution.X;
            int height = Constants.InternalResolution.Y;
            var rand = GameEngine.Random;

            _drops.Clear();            for (int i = 0; i < amount; i++)
            {
                int radius = rand.Next(1, 4);
                float initialSpeedY = (float)rand.NextDouble() * 40f + 10f;
                _drops.Add(new Drop
                {
                    Position = new Vector2((float)rand.NextDouble() * width, (float)rand.NextDouble() * height),
                    Velocity = new Vector2((float)(rand.NextDouble() - 0.5) * 10f, initialSpeedY),                    Radius = radius,
                    Color = new Color(70, 70, 70)
                });
            }
        }
        public void Update(float gravity = 90f, float wind = 15f, float dt = 1f / 60f)        {
            if (dt <= 0f) return;
            int width = Constants.InternalResolution.X;
            int height = Constants.InternalResolution.Y;

            for (int i = 0; i < _drops.Count; i++)
            {
                var drop = _drops[i];
                drop.Velocity.Y += gravity * dt;
                drop.Velocity.Y = Math.Min(drop.Velocity.Y, _maxFallSpeed);                drop.Velocity.X = MathHelper.Lerp(drop.Velocity.X, wind, 0.01f);                drop.Position += drop.Velocity * dt;
                if (drop.Position.Y - drop.Radius > height)
                {
                    ResetDrop(ref drop, width, height);
                }
                else if (drop.Position.Y + drop.Radius < 0)
                {
                    drop.Position.Y = height + drop.Radius;
                }
                if (drop.Position.X - drop.Radius > width) drop.Position.X = -drop.Radius;
                else if (drop.Position.X + drop.Radius < 0) drop.Position.X = width + drop.Radius;


                _drops[i] = drop;
            }
        }
        private void ResetDrop(ref Drop drop, int width, int height)
        {
            var rand = GameEngine.Random;
            drop.Position = new Vector2((float)rand.NextDouble() * width, -drop.Radius - (float)rand.NextDouble() * 20f);
            float initialSpeedY = (float)rand.NextDouble() * 40f + 10f;            drop.Velocity = new Vector2((float)(rand.NextDouble() - 0.5) * 10f, initialSpeedY);
            drop.Radius = rand.Next(1, 4);
        }
        public void Draw(SpriteBatch spriteBatch, Color? overrideColor = null)
        {
            if (Explosion.PixelTexture == null) return;

            for (int i = 0; i < _drops.Count; i++)
            {
                var drop = _drops[i];
                Color c = overrideColor ?? drop.Color;
                byte alpha = (byte)MathHelper.Clamp(120 + drop.Radius * 40, 60, 255);
                var drawColor = new Color(c.R, c.G, c.B, alpha);
                float scale = drop.Radius * 2f;
                float depth = 0.0f;

                spriteBatch.Draw(
                    Explosion.PixelTexture,
                    drop.Position,
                    null,
                    drawColor,
                    0f,
                    new Vector2(0.5f, 0.5f),                    scale,
                    SpriteEffects.None,
                    depth                );
            }
        }
    }
}

Classes\Particles\Particle.cs:
Directory: Classes\Particles

﻿using Microsoft.Xna.Framework;

namespace IsometricGame.Classes.Particles
{
    public struct Particle
    {
        public Vector2 Position;        public Vector2 Origin;
        public Vector2 Velocity;
        public Color Color;
        public float MaxRange;

        public Particle(Vector2 position, Vector2 origin, Vector2 velocity, Color color, float maxRange)
        {
            Position = position;
            Origin = origin;
            Velocity = velocity;
            Color = color;
            MaxRange = maxRange;
        }
    }
}

Classes\Player.cs:
Directory: Classes

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Audio;
using System.Collections.Generic;
using IsometricGame.Classes.Particles;
using System;

namespace IsometricGame.Classes
{
    public class Player : Sprite
    {
        private Dictionary<string, Texture2D> _sprites;
        private string _currentDirection = "south";

        private double _shotDelay = 0.25;
        private double _lastShot;

        private bool _movingRight, _movingLeft, _movingUp, _movingDown, _firing;
        private float _speed = 4.0f;
        public int Life { get; private set; }
        public Explosion ExplosionEffect { get; private set; }
        private double _lastHit;
        private double _invincibilityDuration = 1000;
        private bool _isInvincible = false;


        public Player(Vector2 worldPos) : base(null, worldPos)
        {
            _sprites = new Dictionary<string, Texture2D>
            {
                { "south", GameEngine.Assets.Images["player_idle_south"] },
                { "west", GameEngine.Assets.Images["player_idle_west"] },
                { "north", GameEngine.Assets.Images["player_idle_north"] },
                { "east", GameEngine.Assets.Images["player_idle_east"] }
            };

            if (_sprites.ContainsKey(_currentDirection))                
                UpdateTexture(_sprites[_currentDirection]);
            if (Texture != null)
                Origin = new Vector2(Texture.Width / 2f, Texture.Height);

            Life = Constants.MaxLife;
            ExplosionEffect = new Explosion();
        }

        public void GetInput(InputManager input)
        {
            _movingLeft = input.IsKeyDown("LEFT");
            _movingRight = input.IsKeyDown("RIGHT");
            _movingUp = input.IsKeyDown("UP");
            _movingDown = input.IsKeyDown("DOWN");
            _firing = input.IsKeyDown("FIRE");
        }

        private void Fire(GameTime gameTime)
        {
            _lastShot = gameTime.TotalGameTime.TotalSeconds;
            Vector2 shotDirection = Vector2.Zero;
            switch (_currentDirection)
            {
                // Mapeia direções da TELA para vetores do MUNDO
                case "north": shotDirection = new Vector2(-1, -1); break; // Cima da Tela
                case "south": shotDirection = new Vector2(1, 1); break;   // Baixo da Tela
                case "west": shotDirection = new Vector2(-1, 1); break;  // Esquerda da Tela
                case "east": shotDirection = new Vector2(1, -1); break;  // Direita da Tela
                default: shotDirection = new Vector2(1, 1); break; // Padrão
            }

            var bullets = Bullet.CreateBullets(
                pattern: "single",
                worldPos: this.WorldPosition,
                worldDirection: shotDirection, // O vetor do mundo já está correto
                isFromPlayer: true
            );

            foreach (var bullet in bullets)
            {
                GameEngine.PlayerBullets.Add(bullet);
                GameEngine.AllSprites.Add(bullet);
            }
            GameEngine.Assets.Sounds["shoot"].Play();
        }

        private void Animate()
        {
            string targetDirection = _currentDirection;

            if (_movingUp) targetDirection = "north";
            else if (_movingDown) targetDirection = "south";
            else if (_movingLeft) targetDirection = "west";
            else if (_movingRight) targetDirection = "east";

            _currentDirection = targetDirection;

            if (_sprites.ContainsKey(_currentDirection))
                UpdateTexture(_sprites[_currentDirection]);
            if (Texture != null)
                Origin = new Vector2(Texture.Width / 2f, Texture.Height);
        }
        public override void Update(GameTime gameTime, float dt)
        {
            double totalMilliseconds = gameTime.TotalGameTime.TotalMilliseconds;

            ExplosionEffect.Update(dt);
            Animate();
            _isInvincible = totalMilliseconds - _lastHit < _invincibilityDuration;

            Vector2 worldDirection = Vector2.Zero;
            if (_movingUp) worldDirection += new Vector2(-1, -1); // Cima (Norte)
            if (_movingDown) worldDirection += new Vector2(1, 1);   // Baixo (Sul)
            if (_movingLeft) worldDirection += new Vector2(-1, 1);  // Esquerda (Oeste)
            if (_movingRight) worldDirection += new Vector2(1, -1);  // Direita (Leste)

            if (worldDirection != Vector2.Zero)
            {
                worldDirection.Normalize();
            }
            WorldVelocity = worldDirection * _speed;
            base.Update(gameTime, dt);

            if (_firing && (gameTime.TotalGameTime.TotalSeconds - _lastShot > _shotDelay))
            {
                Fire(gameTime);
            }
        }

        public void TakeDamage(GameTime gameTime)
        {
            double totalMilliseconds = gameTime.TotalGameTime.TotalMilliseconds;
            if (!_isInvincible)            {
                Life -= 1;
                _lastHit = totalMilliseconds;                _isInvincible = true;
                if (Texture != null)
                    ExplosionEffect.Create(this.ScreenPosition.X, this.ScreenPosition.Y - (this.Texture.Height / 2f), Constants.PlayerColorGreen, speed: -5);
                GameEngine.Assets.Sounds["hit"].Play();
                GameEngine.ScreenShake = 15;
                if (Life <= 0)
                {
                    Kill();                }
            }
        }


        public override void Draw(SpriteBatch spriteBatch)
        {
            if (_isInvincible && !IsRemoved)
            {
                float flicker = (float)DateTime.Now.TimeOfDay.TotalMilliseconds / 100f;
                if ((int)flicker % 2 == 0)
                {
                    return;
                }
            }

            base.Draw(spriteBatch);
            ExplosionEffect.Draw(spriteBatch);
        }
    }
}

Classes\Sprite.cs:
Directory: Classes

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System;

namespace IsometricGame.Classes
{
    public class Sprite
    {
        public Texture2D Texture { get; set; }
        public Vector2 WorldPosition { get; set; }
        public Vector2 ScreenPosition { get; protected set; }
        public Vector2 WorldVelocity { get; set; }

        public bool IsRemoved { get; set; } = false;
        public Vector2 Origin { get; protected set; }

        public Sprite(Texture2D texture, Vector2 worldPosition)
        {
            WorldPosition = worldPosition;
            WorldVelocity = Vector2.Zero;

            // Esta é a mudança principal:
            // Precisamos chamar UpdateTexture para definir a Texture E a Origin.
            // A Origin correta (base da imagem) é essencial para o sorting isométrico.
            UpdateTexture(texture);

            UpdateScreenPosition();
        }

        protected void UpdateTexture(Texture2D newTexture)
        {
            if (newTexture != null)
            {
                Texture = newTexture;
                Origin = new Vector2(Texture.Width / 2f, Texture.Height / 2f);
            }
        }

        protected void UpdateScreenPosition()
        {
            ScreenPosition = IsoMath.WorldToScreen(WorldPosition);
        }
        public virtual void Update(GameTime gameTime, float dt)
        {
            WorldPosition += WorldVelocity * dt;
            UpdateScreenPosition();
        }

        public virtual void Draw(SpriteBatch spriteBatch)
        {
            if (Texture != null && !IsRemoved)
            {
                // --- INÍCIO DA MODIFICAÇÃO ---
                // Arredonda as coordenadas X e Y para o inteiro mais próximo
                // Isso "trava" o sprite na grade de pixels, evitando micro-desalinhamentos.
                Vector2 drawPosition = new Vector2(
                    MathF.Round(ScreenPosition.X),
                    MathF.Round(ScreenPosition.Y)
                );
                // --- FIM DA MODIFICAÇÃO ---

                float depth = IsoMath.GetDepth(WorldPosition);

                spriteBatch.Draw(Texture,
                                 // Usa a posição arredondada
                                 drawPosition,
                                 null,
                                 Color.White,
                                 0f,
                                 Origin,
                                 1.0f,
                                 SpriteEffects.None,
                                 depth);
            }
        }

        public void Kill() => IsRemoved = true;
    }
}

Classes\States\DrawUtils.cs:
Directory: Classes\States

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;
using System;

namespace IsometricGame.States
{
    public static class DrawUtils
    {
        public static void DrawText(SpriteBatch spriteBatch, string text, SpriteFont font, Vector2 position, Color color, float depth = 1.0f)
        {
            Vector2 origin = font.MeasureString(text) / 2f;
            spriteBatch.DrawString(font, text, position, color, 0, origin, 1.0f, SpriteEffects.None, depth);
        }

        // Nova função para desenhar texto em coordenadas de TELA
        public static void DrawTextScreen(SpriteBatch spriteBatch, string text, SpriteFont font, Vector2 position, Color color, float depth = 1.0f)
        {
            Vector2 origin = font.MeasureString(text) / 2f;
            spriteBatch.DrawString(font, text, position, color, 0, origin, 1.0f, SpriteEffects.None, depth);
        }

        public static void DrawVerticalGradient(SpriteBatch spriteBatch, GraphicsDevice graphicsDevice, Color color1, Color color2)
        {
            Texture2D pixel = GameEngine.Assets.Images["pixel"];
            int width = Constants.InternalResolution.X;
            int height = Constants.InternalResolution.Y;
            Vector2 cameraTopLeft = Game1.Camera.ScreenToWorld(Vector2.Zero);

            for (int y = 0; y < height; y++)
            {
                float amount = (float)y / (float)height;
                Color lerpedColor = Color.Lerp(color1, color2, amount);
                spriteBatch.Draw(pixel, new Rectangle((int)cameraTopLeft.X, (int)cameraTopLeft.Y + y, width, 1), lerpedColor);
            }
        }

        public static void DrawMenu(SpriteBatch spriteBatch, List<string> options, string title, int selected)
        {
            Texture2D pixel = GameEngine.Assets.Images["pixel"];
            SpriteFont fontTitle = GameEngine.Assets.Fonts["captain_80"];
            SpriteFont fontOption = GameEngine.Assets.Fonts["captain_42"];

            // Não converte mais para "mundo", usa o centro da tela interna
            Vector2 center = new Vector2(Constants.InternalResolution.X / 2f, Constants.InternalResolution.Y / 2f);

            if (!string.IsNullOrEmpty(title))
            {
                // Usa coordenadas de tela
                Vector2 titlePos = new Vector2(Constants.InternalResolution.X / 2f, Constants.InternalResolution.Y / 2f - 150);
                // Usa a nova função DrawTextScreen
                DrawTextScreen(spriteBatch, title, fontTitle, titlePos, Constants.TitleYellow1, 1.0f);
            }

            float yGap = 50f;
            // Usa o centro da tela
            Vector2 startPosScreen = new Vector2(center.X, center.Y - (options.Count / 2f * yGap) + 50f);

            for (int i = 0; i < options.Count; i++)
            {
                Color color = (i == selected) ? Constants.GameColor : Color.White;
                Vector2 posScreen = new Vector2(startPosScreen.X, startPosScreen.Y + i * yGap);

                // Usa a nova função DrawTextScreen
                DrawTextScreen(spriteBatch, options[i], fontOption, posScreen, color, 1.0f);

                if (i == selected)
                {
                    float textWidth = fontOption.MeasureString(options[i]).X / 2f;
                    // Usa coordenadas de tela
                    Vector2 leftMarkerPos = new Vector2(posScreen.X - textWidth - 20, posScreen.Y);
                    Vector2 rightMarkerPos = new Vector2(posScreen.X + textWidth + 20, posScreen.Y);

                    // Usa a nova função DrawTextScreen
                    DrawTextScreen(spriteBatch, "|", fontOption, leftMarkerPos, color, 1.0f);
                    DrawTextScreen(spriteBatch, "|", fontOption, rightMarkerPos, color, 1.0f);
                }
            }
            // --- FIM DA MODIFICAÇÃO ---
        }
    }
}

Classes\States\ExitConfirmState.cs:
Directory: Classes\States

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace IsometricGame.States
{
    public class ExitConfirmState : GameStateBase
    {
        private List<string> _options = new List<string> { "EXIT TO MAIN-MENU", "EXIT TO DESKTOP", "BACK" };
        private int _selected = 0;
        private string _previousState = "Menu";
        public override void Start()
        {
            base.Start();
            _selected = 0;
            _previousState = (GameEngine.Player != null) ? "Pause" : "Menu";
            if (_previousState == "Pause")
                Game1.Camera.Follow(GameEngine.Player.ScreenPosition);
            else
                Game1.Camera.Follow(Vector2.Zero);
        }

        public override void Update(GameTime gameTime, InputManager input)
        {
            if (input.IsKeyPressed("DOWN"))
            {
                _selected = (_selected + 1) % _options.Count;
                GameEngine.Assets.Sounds["menu_select"].Play();
            }
            if (input.IsKeyPressed("UP"))
            {
                _selected = (_selected - 1 + _options.Count) % _options.Count;
                GameEngine.Assets.Sounds["menu_select"].Play();
            }

            if (input.IsKeyPressed("ESC"))
            {
                IsDone = true;
                NextState = _previousState;            }

            if (input.IsKeyPressed("START"))
            {
                GameEngine.Assets.Sounds["menu_confirm"].Play();
                IsDone = true;
                if (_selected == 0)
                {
                    NextState = "Menu";
                }
                else if (_selected == 1)
                {
                    NextState = "Exit";
                }
                else if (_selected == 2)
                {
                    NextState = _previousState;                }
            }
        }

        public override void Draw(SpriteBatch spriteBatch, GraphicsDevice graphicsDevice)
        {
            DrawUtils.DrawMenu(spriteBatch, _options, "EXIT", _selected);
        }
    }
}

Classes\States\GameOverState.cs:
Directory: Classes\States

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace IsometricGame.States
{
    public class GameOverState : GameStateBase
    {
        private List<string> _options = new List<string> { "RESTART", "EXIT" };
        private int _selected = 0;
        public GameOverState() { }

        public override void Start()
        {
            base.Start();
            _selected = 0;
        }

        public override void Update(GameTime gameTime, InputManager input)
        {
            if (input.IsKeyPressed("DOWN"))
            {
                _selected = (_selected + 1) % _options.Count;
                GameEngine.Assets.Sounds["menu_select"]?.Play();
            }
            if (input.IsKeyPressed("UP"))
            {
                _selected = (_selected - 1 + _options.Count) % _options.Count;
                GameEngine.Assets.Sounds["menu_select"]?.Play();
            }

            if (input.IsKeyPressed("START"))
            {
                GameEngine.Assets.Sounds["menu_confirm"]?.Play();
                IsDone = true;
                if (_selected == 0)
                {
                    NextState = "Menu";
                }
                else if (_selected == 1)
                {
                    NextState = "ExitConfirm";
                }
            }
        }

        public override void Draw(SpriteBatch spriteBatch, GraphicsDevice graphicsDevice)
        {
            DrawUtils.DrawMenu(spriteBatch, _options, "GAME OVER", _selected);
        }
    }
}

Classes\States\GameplayState.cs:
Directory: Classes\States

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using IsometricGame.Classes;
using IsometricGame.Classes.Particles;
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
namespace IsometricGame.States
{
    public class GameplayState : GameStateBase
    {
        private Explosion _hitExplosion;
        private Fall _backgroundFall;
        private MapGenerator _mapGenerator;

        public override void Start()
        {
            base.Start();
            GameEngine.ResetGame();

            _hitExplosion = new Explosion();
            _backgroundFall = new Fall(300);

            // 1. Gera o mapa PRIMEIRO
            _mapGenerator = new MapGenerator();
            _mapGenerator.GenerateMap(); // Isso irá popular GameEngine.AllSprites com tiles

            // 2. Adiciona o Player
            Vector2 playerPos = new Vector2(10, 10); // Posição inicial no meio do "castelo"
            GameEngine.Player = new Player(playerPos);
            GameEngine.AllSprites.Add(GameEngine.Player); // Adiciona o player DEPOIS dos tiles

            // 3. Adiciona os Inimigos
            SpawnEnemies();
        }

        private void SpawnEnemies()
        {
            for (int i = 0; i < GameEngine.Level * 5; i++)
            {
                float x = GameEngine.Random.Next(-10, 10);
                float y = GameEngine.Random.Next(-10, 10);
                if (Math.Abs(x) < 2 && Math.Abs(y) < 2) continue;
                SpawnEnemy(typeof(Enemy1), new Vector2(x, y));
            }
        }

        private void SpawnEnemy(Type enemyType, Vector2 worldPos)
        {
            EnemyBase enemy = null;
            if (enemyType == typeof(Enemy1)) enemy = new Enemy1(worldPos);

            if (enemy != null)
            {
                GameEngine.AllEnemies.Add(enemy);
                GameEngine.AllSprites.Add(enemy);
            }
        }

        public override void Update(GameTime gameTime, InputManager input)
        {
            float dt = (float)gameTime.ElapsedGameTime.TotalSeconds;
            float effectiveDt = dt * Constants.BaseSpeedMultiplier;
            if (input.IsKeyPressed("ESC"))
            {
                IsDone = true;
                NextState = "Pause";
                return;            }
            if (GameEngine.Player == null)
            {
                if (!IsDone)
                {
                    IsDone = true;
                    NextState = "GameOver";
                }
                return;            }
            GameEngine.Player.GetInput(input);
            _hitExplosion.Update(effectiveDt);
            for (int i = GameEngine.AllSprites.Count - 1; i >= 0; i--)
            {
                if (i < GameEngine.AllSprites.Count)
                {
                    var sprite = GameEngine.AllSprites[i];
                    if (!sprite.IsRemoved)
                    {
                        sprite.Update(gameTime, effectiveDt);
                    }
                }
            }
            HandleCollisions(gameTime);
            CleanupSprites();
            if (GameEngine.Player == null)
            {
                if (!IsDone)
                {
                    IsDone = true;
                    NextState = "GameOver";
                }
                return;            }
            if (GameEngine.AllEnemies.Count == 0)
            {
                GameEngine.Level++;
                SpawnEnemies();
            }
        }
        private void HandleCollisions(GameTime gameTime)
        {
            if (GameEngine.Player == null || GameEngine.Player.IsRemoved) return;
            const float enemyCollisionRadius = 0.8f;
            const float bulletCollisionRadius = 0.3f;
            const float playerCollisionRadius = 0.6f;
            for (int i = GameEngine.AllEnemies.Count - 1; i >= 0; i--)
            {
                var enemy = GameEngine.AllEnemies[i];
                if (enemy.IsRemoved) continue;

                for (int j = GameEngine.PlayerBullets.Count - 1; j >= 0; j--)
                {
                    var bullet = GameEngine.PlayerBullets[j];
                    if (bullet.IsRemoved) continue;

                    if (Vector2.Distance(bullet.WorldPosition, enemy.WorldPosition) < (enemyCollisionRadius + bulletCollisionRadius))
                    {
                        if (enemy.Texture != null)
                            _hitExplosion.Create(enemy.ScreenPosition.X, enemy.ScreenPosition.Y - enemy.Texture.Height / 2f);
                        enemy.Damage(gameTime);
                        bullet.Kill();
                    }
                }
            }
            if (!GameEngine.Player.IsRemoved)
            {
                for (int i = GameEngine.EnemyBullets.Count - 1; i >= 0; i--)
                {
                    var bullet = GameEngine.EnemyBullets[i];
                    if (bullet.IsRemoved) continue;

                    if (Vector2.Distance(bullet.WorldPosition, GameEngine.Player.WorldPosition) < (playerCollisionRadius + bulletCollisionRadius))
                    {
                        GameEngine.Player.TakeDamage(gameTime);
                        bullet.Kill();
                        if (GameEngine.Player.IsRemoved) break;                    }
                }
                if (!GameEngine.Player.IsRemoved)
                {
                    for (int i = GameEngine.AllEnemies.Count - 1; i >= 0; i--)
                    {
                        var enemy = GameEngine.AllEnemies[i];
                        if (enemy.IsRemoved) continue;

                        if (Vector2.Distance(enemy.WorldPosition, GameEngine.Player.WorldPosition) < (enemyCollisionRadius + playerCollisionRadius))
                        {
                            GameEngine.Player.TakeDamage(gameTime);
                            enemy.Kill();
                            GameEngine.ScreenShake = 5;
                            if (GameEngine.Player.IsRemoved) break;                        }
                    }
                }
            }
        }
        private void CleanupSprites()
        {
            GameEngine.AllSprites.RemoveAll(s => s.IsRemoved);
            GameEngine.AllEnemies.RemoveAll(e => e.IsRemoved);
            GameEngine.PlayerBullets.RemoveAll(b => b.IsRemoved);
            GameEngine.EnemyBullets.RemoveAll(b => b.IsRemoved);

            if (GameEngine.Player != null && GameEngine.Player.IsRemoved)
            {
                GameEngine.Player = null;
            }
        }

        public void DrawWorld(SpriteBatch spriteBatch)
        {
            foreach (var sprite in GameEngine.AllSprites)
            {
                if (!sprite.IsRemoved)
                    sprite.Draw(spriteBatch);
            }

            if (GameEngine.Player != null)
                GameEngine.Player.ExplosionEffect.Draw(spriteBatch);

            _hitExplosion.Draw(spriteBatch);
        }
        public override void Draw(SpriteBatch spriteBatch, GraphicsDevice graphicsDevice)
        {
            // O código de desenhar sprites foi movido para DrawWorld()

            var font = GameEngine.Assets.Fonts["captain_32"];

            // Usa coordenadas de tela
            Vector2 levelPos = new Vector2(Constants.InternalResolution.X - 100, 30);
            Vector2 lifePos = new Vector2(Constants.InternalResolution.X - 100, 60);

            // Usa a nova função DrawTextScreen
            DrawUtils.DrawTextScreen(spriteBatch, $"Level {GameEngine.Level}", font, levelPos, Color.White, 1.0f);
            if (GameEngine.Player != null)
                DrawUtils.DrawTextScreen(spriteBatch, $"Life  {GameEngine.Player.Life}", font, lifePos, Color.White, 1.0f);
            else
                DrawUtils.DrawTextScreen(spriteBatch, "Life  0", font, lifePos, Color.Red, 1.0f);
        }
    }
}

Classes\States\GameStateBase.cs:
Directory: Classes\States

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace IsometricGame.States
{
    public abstract class GameStateBase
    {
        public bool IsDone { get; protected set; }
        public string NextState { get; protected set; }

        public virtual void Start()
        {
            IsDone = false;
            NextState = string.Empty;
        }

        public abstract void Update(GameTime gameTime, InputManager input);

        public abstract void Draw(SpriteBatch spriteBatch, GraphicsDevice graphicsDevice);
    }
}

Classes\States\MenuState.cs:
Directory: Classes\States

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;
using System;
using System.Diagnostics;
namespace IsometricGame.States
{
    public class MenuState : GameStateBase
    {
        private List<string> _options = new List<string> { "START", "OPTIONS", "EXIT" };
        private int _selected = 0;
        private float _titleOffsetY;

        public override void Start()
        {
            base.Start();
            _selected = 0;
            Debug.WriteLine("MenuState Started.");        }

        public override void Update(GameTime gameTime, InputManager input)
        {
            _titleOffsetY = (float)(Math.Sin(gameTime.TotalGameTime.TotalSeconds * 2 * Math.PI) * (Constants.InternalResolution.Y * 0.04));

            if (input.IsKeyPressed("DOWN"))
            {
                Debug.WriteLine($"MenuState detected: DOWN");
                _selected = (_selected + 1) % _options.Count;
                GameEngine.Assets.Sounds["menu_select"]?.Play();            }
            if (input.IsKeyPressed("UP"))
            {
                Debug.WriteLine($"MenuState detected: UP");
                _selected = (_selected - 1 + _options.Count) % _options.Count;
                GameEngine.Assets.Sounds["menu_select"]?.Play();
            }

            if (input.IsKeyPressed("START"))
            {
                Debug.WriteLine($"MenuState detected: START");
                GameEngine.Assets.Sounds["menu_confirm"]?.Play();
                IsDone = true;
                if (_selected == 0) NextState = "Game";
                else if (_selected == 1) NextState = "Options";
                else if (_selected == 2) NextState = "Exit";
            }
            if (input.IsKeyPressed("ESC"))
            {
                Debug.WriteLine($"MenuState detected: ESC (mapped to Exit)");
                IsDone = true;
                NextState = "Exit";            }
        }
        public override void Draw(SpriteBatch spriteBatch, GraphicsDevice graphicsDevice)
        {
            Vector2 titlePosScreen = new Vector2(Constants.InternalResolution.X / 2f, Constants.InternalResolution.Y * 0.33f + _titleOffsetY);
            Vector2 titlePosWorld = Game1.Camera.ScreenToWorld(titlePosScreen);
            DrawUtils.DrawText(spriteBatch, "Isometric Game Base", GameEngine.Assets.Fonts["captain_80"], titlePosWorld, Constants.TitleYellow1, 1.0f);
            DrawUtils.DrawMenu(spriteBatch, _options, "", _selected);
        }
    }
}

Classes\States\OptionsState.cs:
Directory: Classes\States

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;
using System.Linq;
using System;using System.Diagnostics;
namespace IsometricGame.States
{
    public class OptionsState : GameStateBase
    {
        private List<string> _options = new List<string>();
        private int _selected = 0;

        private int _currentResIndex;
        private bool _currentShowFps;
        private bool _currentFullscreen;

        private const string OptRes = "RESOLUTION";
        private const string OptFps = "SHOW FPS";
        private const string OptFs = "FULLSCREEN";
        private const string OptApply = "APPLY";
        private const string OptBack = "BACK";
        public OptionsState() { }

        public override void Start()
        {
            base.Start();
            _selected = 0;

            _currentResIndex = Constants.Resolutions.ToList().IndexOf(Constants.WindowSize);
            if (_currentResIndex < 0) _currentResIndex = 0;

            _currentShowFps = Constants.ShowFPS;
            _currentFullscreen = Constants.SetFullscreen;
            UpdateOptionsText();        }

        private void UpdateOptionsText()
        {
            _options.Clear();
            _options.Add($"{OptRes} - {Constants.Resolutions[_currentResIndex].X}x{Constants.Resolutions[_currentResIndex].Y}");
            _options.Add($"{OptFps}: {(_currentShowFps ? "ON" : "OFF")}");
            _options.Add($"{OptFs}: {(_currentFullscreen ? "ON" : "OFF")}");
            _options.Add(OptApply);
            _options.Add(OptBack);
        }


        public override void Update(GameTime gameTime, InputManager input)
        {
            bool selectionChanged = false;
            if (input.IsKeyPressed("DOWN"))
            {
                _selected = (_selected + 1) % _options.Count;
                selectionChanged = true;
            }
            if (input.IsKeyPressed("UP"))
            {
                _selected = (_selected - 1 + _options.Count) % _options.Count;
                selectionChanged = true;
            }

            if (selectionChanged)
            {
                GameEngine.Assets.Sounds["menu_select"]?.Play();
            }


            if (input.IsKeyPressed("ESC"))
            {
                IsDone = true;
                NextState = "Menu";
                return;            }
            if (_options == null || _options.Count == 0)
            {
                Debug.WriteLine("Error: Options list is empty in OptionsState.Update!");
                UpdateOptionsText();
                if (_options.Count == 0) return;            }
            _selected = Math.Clamp(_selected, 0, _options.Count - 1);
            string currentOptionText = _options[_selected];
            string currentOptionAction = currentOptionText.Split(' ')[0];
            if (currentOptionAction == OptRes)
            {
                bool optionTextChanged = false;
                if (input.IsKeyPressed("RIGHT"))
                {
                    _currentResIndex = (_currentResIndex + 1) % Constants.Resolutions.Length;
                    optionTextChanged = true;
                    selectionChanged = true;                }
                if (input.IsKeyPressed("LEFT"))
                {
                    _currentResIndex = (_currentResIndex - 1 + Constants.Resolutions.Length) % Constants.Resolutions.Length;
                    optionTextChanged = true;
                    selectionChanged = true;                }
                if (optionTextChanged) UpdateOptionsText();                if (selectionChanged && !input.IsKeyPressed("UP") && !input.IsKeyPressed("DOWN"))                    GameEngine.Assets.Sounds["menu_select"]?.Play();
            }

            if (input.IsKeyPressed("START"))
            {
                GameEngine.Assets.Sounds["menu_confirm"]?.Play();

                switch (currentOptionAction)                {
                    case OptFps:
                        _currentShowFps = !_currentShowFps;
                        UpdateOptionsText();                        break;

                    case OptFs:
                        _currentFullscreen = !_currentFullscreen;
                        UpdateOptionsText();                        break;

                    case OptApply:
                        Game1.ApplySettings(Constants.Resolutions[_currentResIndex], _currentFullscreen);
                        Constants.ShowFPS = _currentShowFps;
                        break;

                    case OptBack:
                        IsDone = true;
                        NextState = "Menu";
                        break;
                    case OptRes:
                        break;
                }
            }
        }
        public override void Draw(SpriteBatch spriteBatch, GraphicsDevice graphicsDevice)
        {
            DrawUtils.DrawMenu(spriteBatch, _options, "OPTIONS", _selected);
        }
    }
}

Classes\States\PauseState.cs:
Directory: Classes\States

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using System.Collections.Generic;

namespace IsometricGame.States
{
    public class PauseState : GameStateBase
    {
        private List<string> _options = new List<string> { "CONTINUE", "EXIT" };
        private int _selected = 0;

        public override void Start()
        {
            base.Start();
            _selected = 0;
            Game1.Camera.Follow(GameEngine.Player.ScreenPosition);
        }

        public override void Update(GameTime gameTime, InputManager input)
        {
            if (input.IsKeyPressed("DOWN"))
            {
                _selected = (_selected + 1) % _options.Count;
                GameEngine.Assets.Sounds["menu_select"].Play();
            }
            if (input.IsKeyPressed("UP"))
            {
                _selected = (_selected - 1 + _options.Count) % _options.Count;
                GameEngine.Assets.Sounds["menu_select"].Play();
            }

            if (input.IsKeyPressed("ESC"))
            {
                IsDone = true;
                NextState = "Game";
            }

            if (input.IsKeyPressed("START"))
            {
                GameEngine.Assets.Sounds["menu_confirm"].Play();
                IsDone = true;
                if (_selected == 0)
                {
                    NextState = "Game";
                }
                else if (_selected == 1)
                {
                    NextState = "ExitConfirm";
                }
            }
        }

        public override void Draw(SpriteBatch spriteBatch, GraphicsDevice graphicsDevice)
        {
            DrawUtils.DrawMenu(spriteBatch, _options, "PAUSED", _selected);
        }
    }
}

Constants.cs:
Directory: .

﻿using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Input;
using System.Collections.Generic;

namespace IsometricGame
{
    public static class Constants
    {
        public static Point InternalResolution = new Point(1600, 900);
        public static readonly Point[] Resolutions = new Point[]
        {
            new Point(960, 540),
            new Point(1024, 768),
            new Point(1280, 720),
            new Point(1920, 1080),
            new Point(2560, 1440),
            new Point(3840, 2160)
        };
        public static bool ShowFPS = false;
        public static bool SetFullscreen = false;
        public static Point WindowSize = Resolutions[2];
        public const int FrameRate = 75;
        public const int MaxLife = 3;
        public const float BaseSpeedMultiplier = 2.0f;
        public static Point IsoTileSize = new Point(36, 16);
        public static Point WorldSize = new Point(100, 100);
        public static Color BackgroundColor = new Color(15, 25, 27, 200);
        public static Color BackgroundColorGame1 = new Color(15, 25, 27, 255);
        public static Color BackgroundColorGame2 = new Color(15, 25, 27, 255);
        public static Color BackgroundColorMenu1 = new Color(15, 25, 27, 20);
        public static Color BackgroundColorMenu2 = new Color(15, 25, 27, 20);

        public static Color GameColor = new Color(100, 40, 80);
        public static Color TitleYellow1 = new Color(221, 245, 154);
        public static Color TitleYellow2 = new Color(185, 174, 115);
        public static Color PlayerColorGreen = new Color(28, 162, 111);
    }
}

Game1.cs:
Directory: .

﻿using IsometricGame.Classes;
using IsometricGame.Classes.Particles;
using IsometricGame.States;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;
using Microsoft.Xna.Framework.Input;
using Microsoft.Xna.Framework.Media;
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace IsometricGame
{
    public class Game1 : Game
    {
        private GraphicsDeviceManager _graphics;
        private SpriteBatch _spriteBatch;
        public static GraphicsDeviceManager _graphicsManagerInstance;
        private GameStateBase _currentState;
        private readonly Dictionary<string, GameStateBase> _states = new();
        private InputManager _inputManager;
        private RenderTarget2D _renderTarget;
        private Rectangle _renderDestination;
        private Vector2 _screenShakeOffset = Vector2.Zero;
        private double _frameCounter;
        private double _frameTimer;
        private string _fpsDisplay = "";
        public static Camera Camera { get; private set; }
        public static Fall MenuBackgroundFall { get; private set; }

        public Game1()
        {
            _graphics = new GraphicsDeviceManager(this);
            _graphicsManagerInstance = _graphics;
            Content.RootDirectory = "Content";
            IsMouseVisible = true;

            _graphics.PreferredBackBufferWidth = Constants.WindowSize.X;
            _graphics.PreferredBackBufferHeight = Constants.WindowSize.Y;
            _graphics.IsFullScreen = Constants.SetFullscreen;

            IsFixedTimeStep = true;
            TargetElapsedTime = TimeSpan.FromSeconds(1.0 / Constants.FrameRate);
        }

        public static void ApplySettings(Point newResolution, bool fullscreen)
        {
            _graphicsManagerInstance.PreferredBackBufferWidth = newResolution.X;
            _graphicsManagerInstance.PreferredBackBufferHeight = newResolution.Y;
            _graphicsManagerInstance.IsFullScreen = fullscreen;
            _graphicsManagerInstance.ApplyChanges();
        }

        private void CalculateRenderDestination()
        {
            var backBuffer = new Point(
                _graphics.PreferredBackBufferWidth,
                _graphics.PreferredBackBufferHeight
            );

            if (Constants.InternalResolution.X <= 0 || Constants.InternalResolution.Y <= 0)
            {
                Debug.WriteLine("ERROR: Constants.InternalResolution está inválido.");
                _renderDestination = new Rectangle(0, 0, backBuffer.X, backBuffer.Y);
                return;
            }

            float scaleX = (float)backBuffer.X / Constants.InternalResolution.X;
            float scaleY = (float)backBuffer.Y / Constants.InternalResolution.Y;
            float scale = Math.Min(scaleX, scaleY);

            int renderWidth = (int)(Constants.InternalResolution.X * scale);
            int renderHeight = (int)(Constants.InternalResolution.Y * scale);

            _renderDestination = new Rectangle(
                (backBuffer.X - renderWidth) / 2,
                (backBuffer.Y - renderHeight) / 2,
                renderWidth,
                renderHeight
            );
        }

        protected override void Initialize()
        {
            _renderTarget = new RenderTarget2D(
                GraphicsDevice,
                Constants.InternalResolution.X,
                Constants.InternalResolution.Y
            );

            CalculateRenderDestination();
            Window.ClientSizeChanged += (s, e) => CalculateRenderDestination();

            GameEngine.Initialize();
            _inputManager = new InputManager();
            Camera = new Camera(Constants.InternalResolution.X, Constants.InternalResolution.Y);
            MenuBackgroundFall = new Fall(150);
            Camera.SetZoom(2.0f);

            _states.Add("Menu", new MenuState());
            _states.Add("Game", new GameplayState());
            _states.Add("Pause", new PauseState());
            _states.Add("GameOver", new GameOverState());
            _states.Add("Options", new OptionsState());
            _states.Add("ExitConfirm", new ExitConfirmState());
            _states.Add("Exit", new ExitState());

            _currentState = _states["Menu"];
            _currentState.Start();

            base.Initialize();
        }

        protected override void LoadContent()
        {
            _spriteBatch = new SpriteBatch(GraphicsDevice);

            GameEngine.Assets.LoadContent(Content, GraphicsDevice);
            var pixel = new Texture2D(GraphicsDevice, 1, 1);
            pixel.SetData(new[] { Color.White });
            if (GameEngine.Assets.Images.ContainsKey("pixel"))
                GameEngine.Assets.Images["pixel"] = pixel;
            else
                GameEngine.Assets.Images.Add("pixel", pixel);

            Explosion.PixelTexture = pixel;

            Bullet.LoadAssets(GameEngine.Assets);
            EnemyBase.LoadAssets(GameEngine.Assets);
            if (GameEngine.Assets.Music != null)
            {
                MediaPlayer.IsRepeating = true;
                MediaPlayer.Volume = 0.1f;
                MediaPlayer.Play(GameEngine.Assets.Music);
            }
        }

        protected override void Update(GameTime gameTime)
        {
            _inputManager.Update();
            if (GamePad.GetState(PlayerIndex.One).Buttons.Back == ButtonState.Pressed || Keyboard.GetState().IsKeyDown(Keys.F4))
            {
                Exit();
                return;            }
            MenuBackgroundFall.Update(dt: (float)gameTime.ElapsedGameTime.TotalSeconds);
            _currentState.Update(gameTime, _inputManager);
            if (_currentState.IsDone)
            {
                if (!string.IsNullOrEmpty(_currentState.NextState))
                {
                    if (_currentState.NextState == "Exit") { Exit(); return; }                    else if (_states.ContainsKey(_currentState.NextState))
                    {
                        _currentState = _states[_currentState.NextState];
                        _currentState.Start();
                    }
                    else { /* ... fallback ... */ _currentState = _states["Menu"]; _currentState.Start(); }
                }
                else { /* ... fallback ... */ _currentState = _states["Menu"]; _currentState.Start(); }
            }
            if (GameEngine.ScreenShake > 0) { GameEngine.ScreenShake--; _screenShakeOffset.X = GameEngine.Random.Next(-4, 5); _screenShakeOffset.Y = GameEngine.Random.Next(-4, 5); } else { _screenShakeOffset = Vector2.Zero; }
            if (_graphics.PreferredBackBufferWidth != Constants.WindowSize.X || _graphics.PreferredBackBufferHeight != Constants.WindowSize.Y || _graphics.IsFullScreen != Constants.SetFullscreen) { CalculateRenderDestination(); }
            if (_currentState is GameplayState && GameEngine.Player != null) { Camera.Follow(GameEngine.Player.ScreenPosition); }
            else if (!(_currentState is GameplayState)) { Camera.Follow(Vector2.Zero); }
            _frameCounter++;
            _frameTimer += gameTime.ElapsedGameTime.TotalSeconds;
            if (_frameTimer >= 1) { /* ... */ }


            base.Update(gameTime);
        }
        protected override void Draw(GameTime gameTime)
        {
            GraphicsDevice.SetRenderTarget(_renderTarget);
            GraphicsDevice.Clear(Constants.BackgroundColor);

            // --- BATCH 1: Fundos da UI (Sem Câmera) ---
            _spriteBatch.Begin(SpriteSortMode.Deferred, BlendState.AlphaBlend, SamplerState.PointClamp);

            if (_currentState is MenuState || _currentState is OptionsState || _currentState is GameOverState)
            {
                Color fallColor = _currentState is GameOverState ? Constants.GameColor : Color.LightGray;
                MenuBackgroundFall.Draw(_spriteBatch, fallColor);
            }

            _spriteBatch.End();


            // --- BATCH 2: O Mundo (COM Câmera e Zoom) ---
            _spriteBatch.Begin(SpriteSortMode.BackToFront,
                               BlendState.AlphaBlend,
                               SamplerState.PointClamp,
                               null, null, null,
                               Camera.GetViewMatrix()); // <-- ZOOM APLICADO AQUI

            if (_currentState is GameplayState)
            {
                // Chama o novo método que desenha apenas o mundo
                ((GameplayState)_currentState).DrawWorld(_spriteBatch);
            }

            _spriteBatch.End(); // Fim do Batch do Mundo


            // --- BATCH 3: A UI (Sem Câmera) ---
            _spriteBatch.Begin(SpriteSortMode.Deferred,
                               BlendState.AlphaBlend,
                               SamplerState.PointClamp);
            // <-- Sem Matriz, usa Coordenadas de Tela

            // Chama o método Draw padrão, que agora só desenha a UI
            // (Menus, HUD do GameplayState, etc.)
            _currentState.Draw(_spriteBatch, GraphicsDevice);

            if (Constants.ShowFPS && !string.IsNullOrEmpty(_fpsDisplay))
            {
                // Usa a nova função DrawTextScreen
                DrawUtils.DrawTextScreen(_spriteBatch, _fpsDisplay, GameEngine.Assets.Fonts["captain_32"],
                    new Vector2(10, 10), Color.White, 1.0f);
            }

            _spriteBatch.End(); // Fim do Batch da UI


            // --- BATCH 4: Renderização Final para a Janela ---
            GraphicsDevice.SetRenderTarget(null);
            GraphicsDevice.Clear(Color.Black);

            Rectangle destination = _renderDestination;
            destination.Offset(_screenShakeOffset);

            _spriteBatch.Begin(samplerState: SamplerState.PointClamp);
            _spriteBatch.Draw(_renderTarget, destination, Color.White);
            _spriteBatch.End();

            base.Draw(gameTime);
        }
    }

    public class ExitState : GameStateBase
    {
        public override void Draw(SpriteBatch spriteBatch, GraphicsDevice graphicsDevice) { }
        public override void Update(GameTime gameTime, InputManager input) { }
    }
}


GameEngine.cs:
Directory: .

﻿using System.Collections.Generic;
using System;
using IsometricGame.Classes;

namespace IsometricGame
{
    public static class GameEngine
    {
        public static Player Player { get; set; }

        public static List<Sprite> AllSprites { get; private set; }
        public static List<EnemyBase> AllEnemies { get; private set; }
        public static List<Bullet> PlayerBullets { get; private set; }
        public static List<Bullet> EnemyBullets { get; private set; }

        public static AssetManager Assets { get; set; }
        public static int Level { get; set; }
        public static int ScreenShake { get; set; }

        public static Random Random { get; private set; }

        public static void Initialize()
        {
            AllSprites = new List<Sprite>();
            AllEnemies = new List<EnemyBase>();
            PlayerBullets = new List<Bullet>();
            EnemyBullets = new List<Bullet>();
            Assets = new AssetManager();
            Random = new Random();
            Level = 1;
            ScreenShake = 0;
        }

        public static void ResetGame()
        {
            AllSprites.Clear();
            AllEnemies.Clear();
            PlayerBullets.Clear();
            EnemyBullets.Clear();
            Player = null;
            Level = 1;
        }
    }
}

InputManager.cs:
Directory: .

﻿using Microsoft.Xna.Framework.Input;
using System.Collections.Generic;
using System.Diagnostics;using System.Linq;
namespace IsometricGame
{
    public class InputManager
    {
        private KeyboardState _currentKeyState, _previousKeyState;

        private static readonly Dictionary<string, Keys[]> _controls = new Dictionary<string, Keys[]>
        {
            { "UP", new[] { Keys.W, Keys.Up } },
            { "DOWN", new[] { Keys.S, Keys.Down } },
            { "LEFT", new[] { Keys.A, Keys.Left } },
            { "RIGHT", new[] { Keys.D, Keys.Right } },
            { "FIRE", new[] { Keys.Space } },
            { "START", new[] { Keys.Enter, Keys.Space } },
            { "ESC", new[] { Keys.Escape } }
        };

        public void Update()
        {
            _previousKeyState = _currentKeyState;
            _currentKeyState = Keyboard.GetState();
            var pressedKeys = _currentKeyState.GetPressedKeys();
            if (pressedKeys.Length > 0)
            {
                Debug.WriteLine($"InputManager.Update - Current Keys: {string.Join(", ", pressedKeys)}");
            }
        }

        public bool IsKeyDown(string action)
        {
            if (!_controls.ContainsKey(action))
            {
                Debug.WriteLine($"Warning: Input action '{action}' not found in controls map.");
                return false;
            }

            foreach (var key in _controls[action])
            {
                if (_currentKeyState.IsKeyDown(key))
                    return true;
            }
            return false;
        }

        public bool IsKeyPressed(string action)
        {
            if (!_controls.ContainsKey(action))
            {
                return false;
            }

            foreach (var key in _controls[action])
            {
                if (_currentKeyState.IsKeyDown(key) && _previousKeyState.IsKeyUp(key))
                {
                    Debug.WriteLine($"InputManager.IsKeyPressed TRUE for action: {action}, key: {key}");
                    return true;
                }
            }
            return false;
        }
    }
}

IsoMath.cs:
Directory: .

﻿using Microsoft.Xna.Framework;
using System;

namespace IsometricGame
{
    public static class IsoMath
    {
        public static Vector2 WorldToScreen(Vector2 worldPosition)
        {
            float screenX = (worldPosition.X - worldPosition.Y) * (Constants.IsoTileSize.X / 2f);
            float screenY = (worldPosition.X + worldPosition.Y) * (Constants.IsoTileSize.Y / 2f);
            return new Vector2(screenX, screenY);
        }
        public static Vector2 ScreenToWorld(Vector2 screenPosition)
        {
            float tileWidth = Constants.IsoTileSize.X;
            float tileHeight = Constants.IsoTileSize.Y;

            float worldX = (screenPosition.X / (tileWidth / 2f) + screenPosition.Y / (tileHeight / 2f)) / 2f;
            float worldY = (screenPosition.Y / (tileHeight / 2f) - (screenPosition.X / (tileWidth / 2f))) / 2f;
            return new Vector2(worldX, worldY);
        }
        public static float GetDepth(Vector2 worldPosition)
        {
            float totalWorldUnits = Constants.WorldSize.X + Constants.WorldSize.Y;
            float currentWorldUnits = worldPosition.X + worldPosition.Y;

            // Normaliza a profundidade (0.0 para o topo, 1.0 para a base)
            float normalizedDepth = currentWorldUnits / totalWorldUnits;

            // Inverte o valor!
            // Agora o topo (0,0) será 1.0 (desenhado atrás)
            // E a base (100,100) será 0.0 (desenhada na frente)
            return Math.Clamp(1.0f - normalizedDepth, 0.0f, 1.0f);
        }
    }
}

MapGenerator.cs:
Directory: .

﻿using IsometricGame.Classes;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace IsometricGame
{
    public class MapGenerator
    {
        public void GenerateMap()
        {
            Texture2D floorTexture = GameEngine.Assets.Images["tile_floor"];
            Texture2D wallTexture = GameEngine.Assets.Images["tile_wall"];

            // 1. Gerar o Chão
            // Itera por todo o tamanho do mundo definido em Constants
            for (int x = 0; x < Constants.WorldSize.X; x++)
            {
                for (int y = 0; y < Constants.WorldSize.Y; y++)
                {
                    // Cria um novo sprite para o tile de chão
                    var floorTile = new Sprite(floorTexture, new Vector2(x, y));

                    // Adiciona o tile à lista global de sprites para ser renderizado
                    GameEngine.AllSprites.Add(floorTile);
                }
            }

            // 2. Gerar Estruturas (Ex: paredes de um "castelo")
            // Isso demonstra como adicionar estruturas "em cima" do chão
            // O sistema de profundidade (GetDepth) fará o resto.
            for (int i = 5; i < 15; i++)
            {
                // Parede esquerda
                var wallLeft = new Sprite(wallTexture, new Vector2(5, i));
                GameEngine.AllSprites.Add(wallLeft);

                // Parede do fundo
                var wallTop = new Sprite(wallTexture, new Vector2(i, 5));
                GameEngine.AllSprites.Add(wallTop);
            }

            // Adiciona uma "porta"
            var doorTile = new Sprite(floorTexture, new Vector2(5, 10)); // Re-adiciona um tile de chão
            GameEngine.AllSprites.Add(doorTile);
        }
    }
}

obj\Debug\net8.0\.NETCoreApp,Version=v8.0.AssemblyAttributes.cs:
Directory: obj\Debug\net8.0

// <autogenerated />
using System;
using System.Reflection;
[assembly: global::System.Runtime.Versioning.TargetFrameworkAttribute(".NETCoreApp,Version=v8.0", FrameworkDisplayName = ".NET 8.0")]


obj\Debug\net8.0\IsometricGame.AssemblyInfo.cs:
Directory: obj\Debug\net8.0

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Reflection;

[assembly: System.Reflection.AssemblyCompanyAttribute("IsometricGame")]
[assembly: System.Reflection.AssemblyConfigurationAttribute("Debug")]
[assembly: System.Reflection.AssemblyFileVersionAttribute("1.0.0.0")]
[assembly: System.Reflection.AssemblyInformationalVersionAttribute("1.0.0+8223eadf8a9e7a518044734e552020fc0aa8c8d8")]
[assembly: System.Reflection.AssemblyProductAttribute("IsometricGame")]
[assembly: System.Reflection.AssemblyTitleAttribute("IsometricGame")]
[assembly: System.Reflection.AssemblyVersionAttribute("1.0.0.0")]

// Generated by the MSBuild WriteCodeFragment class.



obj\Debug\net8.0\IsometricGame.sourcelink.json:
Directory: obj\Debug\net8.0

{"documents":{"D:\\repos\\IsometricGame-MonoGame\\*":"https://raw.githubusercontent.com/g-brrzzn/IsometricGame-MonoGame/8223eadf8a9e7a518044734e552020fc0aa8c8d8/*"}}

obj\IsometricGame.csproj.nuget.dgspec.json:
Directory: obj

{
  "format": 1,
  "restore": {
    "D:\\repos\\IsometricGame-MonoGame\\IsometricGame\\IsometricGame.csproj": {}
  },
  "projects": {
    "D:\\repos\\IsometricGame-MonoGame\\IsometricGame\\IsometricGame.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "D:\\repos\\IsometricGame-MonoGame\\IsometricGame\\IsometricGame.csproj",
        "projectName": "IsometricGame",
        "projectPath": "D:\\repos\\IsometricGame-MonoGame\\IsometricGame\\IsometricGame.csproj",
        "packagesPath": "C:\\Users\\gabri\\.nuget\\packages\\",
        "outputPath": "D:\\repos\\IsometricGame-MonoGame\\IsometricGame\\obj\\",
        "projectStyle": "PackageReference",
        "fallbackFolders": [
          "C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages"
        ],
        "configFilePaths": [
          "C:\\Users\\gabri\\AppData\\Roaming\\NuGet\\NuGet.Config",
          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config",
          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config"
        ],
        "originalTargetFrameworks": [
          "net8.0"
        ],
        "sources": {
          "C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\": {},
          "C:\\Program Files\\dotnet\\library-packs": {},
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "net8.0": {
            "targetAlias": "net8.0",
            "projectReferences": {}
          }
        },
        "warningProperties": {
          "warnAsError": [
            "NU1605"
          ]
        },
        "restoreAuditProperties": {
          "enableAudit": "true",
          "auditLevel": "low",
          "auditMode": "direct"
        },
        "SdkAnalysisLevel": "9.0.300"
      },
      "frameworks": {
        "net8.0": {
          "targetAlias": "net8.0",
          "dependencies": {
            "MonoGame.Content.Builder.Task": {
              "target": "Package",
              "version": "[3.8.*, )"
            },
            "MonoGame.Framework.DesktopGL": {
              "target": "Package",
              "version": "[3.8.*, )"
            }
          },
          "imports": [
            "net461",
            "net462",
            "net47",
            "net471",
            "net472",
            "net48",
            "net481"
          ],
          "assetTargetFallback": true,
          "warn": true,
          "frameworkReferences": {
            "Microsoft.NETCore.App": {
              "privateAssets": "all"
            }
          },
          "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\9.0.306/PortableRuntimeIdentifierGraph.json"
        }
      }
    }
  }
}

obj\project.assets.json:
Directory: obj

{
  "version": 3,
  "targets": {
    "net8.0": {
      "MonoGame.Content.Builder.Task/3.8.4": {
        "type": "package",
        "build": {
          "build/MonoGame.Content.Builder.Task.props": {},
          "build/MonoGame.Content.Builder.Task.targets": {}
        }
      },
      "MonoGame.Framework.DesktopGL/3.8.4": {
        "type": "package",
        "dependencies": {
          "MonoGame.Library.OpenAL": "1.23.1.10",
          "MonoGame.Library.SDL": "2.32.2.1",
          "NVorbis": "0.10.4"
        },
        "compile": {
          "lib/net8.0/MonoGame.Framework.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/net8.0/MonoGame.Framework.dll": {
            "related": ".xml"
          }
        },
        "build": {
          "build/MonoGame.Framework.DesktopGL.targets": {}
        }
      },
      "MonoGame.Library.OpenAL/1.23.1.10": {
        "type": "package",
        "runtimeTargets": {
          "runtimes/android-arm/native/libopenal.so": {
            "assetType": "native",
            "rid": "android-arm"
          },
          "runtimes/android-arm64/native/libopenal.so": {
            "assetType": "native",
            "rid": "android-arm64"
          },
          "runtimes/android-x64/native/libopenal.so": {
            "assetType": "native",
            "rid": "android-x64"
          },
          "runtimes/android-x86/native/libopenal.so": {
            "assetType": "native",
            "rid": "android-x86"
          },
          "runtimes/ios-arm64/native/libopenal.dylib": {
            "assetType": "native",
            "rid": "ios-arm64"
          },
          "runtimes/iossimulator-arm64/native/libopenal.dylib": {
            "assetType": "native",
            "rid": "iossimulator-arm64"
          },
          "runtimes/iossimulator-x64/native/libopenal.dylib": {
            "assetType": "native",
            "rid": "iossimulator-x64"
          },
          "runtimes/linux-x64/native/libopenal.so": {
            "assetType": "native",
            "rid": "linux-x64"
          },
          "runtimes/osx/native/libopenal.dylib": {
            "assetType": "native",
            "rid": "osx"
          },
          "runtimes/win-x64/native/openal.dll": {
            "assetType": "native",
            "rid": "win-x64"
          }
        }
      },
      "MonoGame.Library.SDL/2.32.2.1": {
        "type": "package",
        "runtimeTargets": {
          "runtimes/linux-x64/native/libSDL2-2.0.so.0": {
            "assetType": "native",
            "rid": "linux-x64"
          },
          "runtimes/osx/native/libSDL2-2.0.0.dylib": {
            "assetType": "native",
            "rid": "osx"
          },
          "runtimes/win-x64/native/SDL2.dll": {
            "assetType": "native",
            "rid": "win-x64"
          }
        }
      },
      "NVorbis/0.10.4": {
        "type": "package",
        "dependencies": {
          "System.Memory": "4.5.3",
          "System.ValueTuple": "4.5.0"
        },
        "compile": {
          "lib/netstandard2.0/NVorbis.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/netstandard2.0/NVorbis.dll": {
            "related": ".xml"
          }
        }
      },
      "System.Memory/4.5.3": {
        "type": "package",
        "compile": {
          "ref/netcoreapp2.1/_._": {}
        },
        "runtime": {
          "lib/netcoreapp2.1/_._": {}
        }
      },
      "System.ValueTuple/4.5.0": {
        "type": "package",
        "compile": {
          "ref/netcoreapp2.0/_._": {}
        },
        "runtime": {
          "lib/netcoreapp2.0/_._": {}
        }
      }
    }
  },
  "libraries": {
    "MonoGame.Content.Builder.Task/3.8.4": {
      "sha512": "Oc/tp6liQ34BkBCrdQO23JDf1Z8r11kKeL9oXSlEfUiRSQYs7C0TYaKIjhfYGjSRaV7JaFIisLDToWpnf7ztKg==",
      "type": "package",
      "path": "monogame.content.builder.task/3.8.4",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "build/MonoGame.Content.Builder.Task.props",
        "build/MonoGame.Content.Builder.Task.targets",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/.nupkg.metadata",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/.signature.p7s",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/Icon.png",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/dotnet-mgcb.3.8.4.nupkg",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/dotnet-mgcb.3.8.4.nupkg.sha512",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/dotnet-mgcb.nupkg",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/dotnet-mgcb.nuspec",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/AssimpNetter.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/BCnEncoder.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/CppNet.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/DotnetToolSettings.xml",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/KtxSharp.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/Microsoft.Toolkit.HighPerformance.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Framework.Content.Pipeline.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Framework.Content.Pipeline.pdb",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Framework.Content.Pipeline.xml",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Framework.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Framework.pdb",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Framework.xml",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Tool.Basisu.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Tool.Crunch.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Tool.FFmpeg.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/MonoGame.Tool.FFprobe.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/SharpDX.D3DCompiler.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/SharpDX.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/libmojoshader_64.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/linux-x64/basisu",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/linux-x64/crunch",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/linux-x64/ffmpeg",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/linux-x64/ffprobe",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/mgcb.deps.json",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/mgcb.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/mgcb.pdb",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/mgcb.runtimeconfig.json",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/mgfxc",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/mgfxc.deps.json",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/mgfxc.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/mgfxc.runtimeconfig.json",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/osx/basisu",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/osx/crunch",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/osx/ffmpeg",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/osx/ffprobe",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/linux-arm64/native/libassimp.so",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/linux-x64/native/libassimp.so",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/linux-x64/native/libfreeimage.so",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/linux-x64/native/libfreetype.so",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/osx-arm64/native/libassimp.dylib",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/osx-x64/native/libassimp.dylib",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/osx/native/libfreeimage.dylib",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/osx/native/libfreetype.dylib",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/win-x64/native/FreeImage.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/win-x64/native/assimp.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/win-x64/native/freetype.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/runtimes/win-x86/native/assimp.dll",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/windows-x64/basisu.exe",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/windows-x64/crunch.exe",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/windows-x64/ffmpeg.exe",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/dotnet-mgcb/3.8.4/tools/net8.0/any/windows-x64/ffprobe.exe",
        "build/dotnet-tools/.store/dotnet-mgcb/3.8.4/project.assets.json",
        "build/dotnet-tools/mgcb.exe",
        "monogame.content.builder.task.3.8.4.nupkg.sha512",
        "monogame.content.builder.task.nuspec"
      ]
    },
    "MonoGame.Framework.DesktopGL/3.8.4": {
      "sha512": "2WR/vPNPcmQ9h4EhMkfpUfMW0Krm6pX0ElkZwSRI1IUecPuzLeXt0i9NRwGxZBUdcNdNxACCmswrxSf4B95Obg==",
      "type": "package",
      "path": "monogame.framework.desktopgl/3.8.4",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "README-packages.md",
        "build/MonoGame.Framework.DesktopGL.targets",
        "lib/net8.0/MonoGame.Framework.dll",
        "lib/net8.0/MonoGame.Framework.xml",
        "monogame.framework.desktopgl.3.8.4.nupkg.sha512",
        "monogame.framework.desktopgl.nuspec"
      ]
    },
    "MonoGame.Library.OpenAL/1.23.1.10": {
      "sha512": "4/F4FFyt7OYhtEmgi/Qmv01eC6GfQ9dkIPsymgkwJ/tV7PewmWrHg/LvTKjd6R+5j/tlO8JkjsEb0Aje6bxfxw==",
      "type": "package",
      "path": "monogame.library.openal/1.23.1.10",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "LICENSE",
        "README.md",
        "monogame.library.openal.1.23.1.10.nupkg.sha512",
        "monogame.library.openal.nuspec",
        "runtimes/android-arm/native/libopenal.so",
        "runtimes/android-arm64/native/libopenal.so",
        "runtimes/android-x64/native/libopenal.so",
        "runtimes/android-x86/native/libopenal.so",
        "runtimes/ios-arm64/native/libopenal.dylib",
        "runtimes/iossimulator-arm64/native/libopenal.dylib",
        "runtimes/iossimulator-x64/native/libopenal.dylib",
        "runtimes/linux-x64/native/libopenal.so",
        "runtimes/osx/native/libopenal.dylib",
        "runtimes/win-x64/native/openal.dll"
      ]
    },
    "MonoGame.Library.SDL/2.32.2.1": {
      "sha512": "T4E2ppGlSTC2L9US1rxtdg3qTbarRzNId31xZoumUW9cf9Nq8nRQPMu9GzvZGrhfSySf0+UWPEj1rlicps+P/w==",
      "type": "package",
      "path": "monogame.library.sdl/2.32.2.1",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "Icon.png",
        "LICENSE.txt",
        "README.md",
        "monogame.library.sdl.2.32.2.1.nupkg.sha512",
        "monogame.library.sdl.nuspec",
        "runtimes/linux-x64/native/libSDL2-2.0.so.0",
        "runtimes/osx/native/libSDL2-2.0.0.dylib",
        "runtimes/win-x64/native/SDL2.dll"
      ]
    },
    "NVorbis/0.10.4": {
      "sha512": "WYnil3DhQHzjCY0dM9I2B3r1vWip90AOuQd25KE4NrjPQBg0tBJFluRLm5YPnO5ZLDmwrfosY8jCQGQRmWI/Pg==",
      "type": "package",
      "path": "nvorbis/0.10.4",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "LICENSE",
        "lib/net45/NVorbis.dll",
        "lib/net45/NVorbis.xml",
        "lib/netstandard2.0/NVorbis.dll",
        "lib/netstandard2.0/NVorbis.xml",
        "nvorbis.0.10.4.nupkg.sha512",
        "nvorbis.nuspec"
      ]
    },
    "System.Memory/4.5.3": {
      "sha512": "3oDzvc/zzetpTKWMShs1AADwZjQ/36HnsufHRPcOjyRAAMLDlu2iD33MBI2opxnezcVUtXyqDXXjoFMOU9c7SA==",
      "type": "package",
      "path": "system.memory/4.5.3",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "LICENSE.TXT",
        "THIRD-PARTY-NOTICES.TXT",
        "lib/netcoreapp2.1/_._",
        "lib/netstandard1.1/System.Memory.dll",
        "lib/netstandard1.1/System.Memory.xml",
        "lib/netstandard2.0/System.Memory.dll",
        "lib/netstandard2.0/System.Memory.xml",
        "ref/netcoreapp2.1/_._",
        "system.memory.4.5.3.nupkg.sha512",
        "system.memory.nuspec",
        "useSharedDesignerContext.txt",
        "version.txt"
      ]
    },
    "System.ValueTuple/4.5.0": {
      "sha512": "okurQJO6NRE/apDIP23ajJ0hpiNmJ+f0BwOlB/cSqTLQlw5upkf+5+96+iG2Jw40G1fCVCyPz/FhIABUjMR+RQ==",
      "type": "package",
      "path": "system.valuetuple/4.5.0",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "LICENSE.TXT",
        "THIRD-PARTY-NOTICES.TXT",
        "lib/MonoAndroid10/_._",
        "lib/MonoTouch10/_._",
        "lib/net461/System.ValueTuple.dll",
        "lib/net461/System.ValueTuple.xml",
        "lib/net47/System.ValueTuple.dll",
        "lib/net47/System.ValueTuple.xml",
        "lib/netcoreapp2.0/_._",
        "lib/netstandard1.0/System.ValueTuple.dll",
        "lib/netstandard1.0/System.ValueTuple.xml",
        "lib/netstandard2.0/_._",
        "lib/portable-net40+sl4+win8+wp8/System.ValueTuple.dll",
        "lib/portable-net40+sl4+win8+wp8/System.ValueTuple.xml",
        "lib/uap10.0.16299/_._",
        "lib/xamarinios10/_._",
        "lib/xamarinmac20/_._",
        "lib/xamarintvos10/_._",
        "lib/xamarinwatchos10/_._",
        "ref/MonoAndroid10/_._",
        "ref/MonoTouch10/_._",
        "ref/net461/System.ValueTuple.dll",
        "ref/net47/System.ValueTuple.dll",
        "ref/netcoreapp2.0/_._",
        "ref/netstandard2.0/_._",
        "ref/portable-net40+sl4+win8+wp8/System.ValueTuple.dll",
        "ref/uap10.0.16299/_._",
        "ref/xamarinios10/_._",
        "ref/xamarinmac20/_._",
        "ref/xamarintvos10/_._",
        "ref/xamarinwatchos10/_._",
        "system.valuetuple.4.5.0.nupkg.sha512",
        "system.valuetuple.nuspec",
        "useSharedDesignerContext.txt",
        "version.txt"
      ]
    }
  },
  "projectFileDependencyGroups": {
    "net8.0": [
      "MonoGame.Content.Builder.Task >= 3.8.*",
      "MonoGame.Framework.DesktopGL >= 3.8.*"
    ]
  },
  "packageFolders": {
    "C:\\Users\\gabri\\.nuget\\packages\\": {},
    "C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages": {}
  },
  "project": {
    "version": "1.0.0",
    "restore": {
      "projectUniqueName": "D:\\repos\\IsometricGame-MonoGame\\IsometricGame\\IsometricGame.csproj",
      "projectName": "IsometricGame",
      "projectPath": "D:\\repos\\IsometricGame-MonoGame\\IsometricGame\\IsometricGame.csproj",
      "packagesPath": "C:\\Users\\gabri\\.nuget\\packages\\",
      "outputPath": "D:\\repos\\IsometricGame-MonoGame\\IsometricGame\\obj\\",
      "projectStyle": "PackageReference",
      "fallbackFolders": [
        "C:\\Program Files (x86)\\Microsoft Visual Studio\\Shared\\NuGetPackages"
      ],
      "configFilePaths": [
        "C:\\Users\\gabri\\AppData\\Roaming\\NuGet\\NuGet.Config",
        "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config",
        "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config"
      ],
      "originalTargetFrameworks": [
        "net8.0"
      ],
      "sources": {
        "C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\": {},
        "C:\\Program Files\\dotnet\\library-packs": {},
        "https://api.nuget.org/v3/index.json": {}
      },
      "frameworks": {
        "net8.0": {
          "targetAlias": "net8.0",
          "projectReferences": {}
        }
      },
      "warningProperties": {
        "warnAsError": [
          "NU1605"
        ]
      },
      "restoreAuditProperties": {
        "enableAudit": "true",
        "auditLevel": "low",
        "auditMode": "direct"
      },
      "SdkAnalysisLevel": "9.0.300"
    },
    "frameworks": {
      "net8.0": {
        "targetAlias": "net8.0",
        "dependencies": {
          "MonoGame.Content.Builder.Task": {
            "target": "Package",
            "version": "[3.8.*, )"
          },
          "MonoGame.Framework.DesktopGL": {
            "target": "Package",
            "version": "[3.8.*, )"
          }
        },
        "imports": [
          "net461",
          "net462",
          "net47",
          "net471",
          "net472",
          "net48",
          "net481"
        ],
        "assetTargetFallback": true,
        "warn": true,
        "frameworkReferences": {
          "Microsoft.NETCore.App": {
            "privateAssets": "all"
          }
        },
        "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\9.0.306/PortableRuntimeIdentifierGraph.json"
      }
    }
  }
}

Program.cs:
Directory: .

﻿using var game = new IsometricGame.Game1();
game.Run();


